<!DOCTYPE html>
<html>
    <head>
	<title>Floored by (math.)floor</title>
	<meta name="description" content="In computing, flooring a number is a common operation. Pretty mundane, but the perks of working with big data is that mundane things get exciting. Big Data breaks language limits." />

	<!-- Required meta tags -->
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">

	<meta property="og:title" content="Floored by (math.)floor" />
	<meta property="og:description" content="" />
	<meta property="og:image" content="" />
	<meta property="og:image:width" content="400" />
	<meta property="og:image:height" content="300" />
	<meta property="og:type" content="website" />


	<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@0.9.4/css/bulma.min.css">

	<link href='https://iamaatoh.com/feed.xml' rel='alternate' type='application/atom+xml'>

		<!-- Global site tag (gtag.js) - Google Analytics -->
	<script async src="https://www.googletagmanager.com/gtag/js?id=UA-111560396-1"></script>
	<script>
		window.dataLayer = window.dataLayer || [];
		function gtag(){dataLayer.push(arguments);}
		gtag('js', new Date());

		gtag('config', 'UA-111560396-1');
		document.fonts.ready.then((fontFaceSet) => {
			document.body.style.opacity = 1
		});
	</script>
	<script>
		let isActive = null
		document.addEventListener('DOMContentLoaded', () => {

			// Get all "navbar-burger" elements
			const $navbarBurgers = Array.prototype.slice.call(document.querySelectorAll('.navbar-burger'), 0);

			// Add a click event on each of them
			$navbarBurgers.forEach( el => {
				el.addEventListener('click', () => {

					// Get the target from the "data-target" attribute
					const target = el.dataset.target;
					const $target = document.getElementById(target);

					// Toggle the "is-active" class on both the "navbar-burger" and the "navbar-menu"
					el.classList.toggle('is-active');
					$target.classList.toggle('is-active');

				});
			});

			// scroll
			const body = (document.getElementsByTagName('body')[0])
			const sideLinks = document.querySelectorAll(".menu-list-item");

			body.addEventListener("scroll", event => {
				// if (window.location.hash) {
				// 	let selected = null
				// 	sideLinks.forEach((s) => { if (s.href.split('#')[1] === window.location.hash.substring(1)) selected = s  })
				// 	if (selected) {
				// 		sideLinks.forEach((s) => s.classList.remove('is-active'))
				// 		selected.classList.add('is-active')
				// 		return
				// 	}
				// }

				let fromTop = body.scrollTop - 250; // top nav + hero
				sideLinks.forEach(link => {
					const id = link.href.split('#')[1]
					let section = document.getElementById(id);
					if (
						section?.offsetTop <= fromTop &&
						section?.offsetTop + section?.offsetHeight > fromTop
					) {
						link.classList.add("is-active");
						isActive = link
					}
				});
				sideLinks.forEach(link => {
					if (link !== isActive) link.classList.remove('is-active')
				})
			}, false);
			});
	</script>

	<style>
		html, body {
			width: 100%;
			height: 100%; 
			position: relative;
			overflow-x: hidden;
			font-family: Verdana, sans-serif;
			scroll-behavior: smooth;
			background-color: #0C1214;
			color: #F5F5F5;
			overflow-y: initial !important;
		}

		strong {
			color: #b5b5b5;
		}

		body::-webkit-scrollbar {
			background: #292929 !important;
			width: 12px;
		}

		body {
			position: relative;
			font-size: 16px !important; 
			line-height: 1.7 !important;
		}


		h1, h2, h3, h4, h5, h6 {
			scroll-margin-top: 100px;
			color: #F5F5F5 !important;
			line-height: 1.4;
		}

		a {
			color: #F5F5F5 !important;
		}

		a:hover {
			text-decoration: underline;
		}

		pre.highlight {
			background-color: black;
			color: wheat
		}

		table {
			background-color: black;
		}

		th {
			color: #b5b5b5 !important;
		}

		code {
			background-color: black;
			color: wheat
		}

		blockquote {
			background-color: transparent !important;
		}

		section {
			padding: 3rem 0!important;
		}

		#logo:hover {
			text-decoration: none;
		}

		.navbar-item:hover {
			text-decoration: none;
		}

		.breadcrumb li {
			white-space: pre-wrap;
			text-decoration: none !important;
		}

		.menu-list a:hover {
			background-color: inherit;
		}

		.navbar.is-dark { 
			background-color:#252629d4 !important;
		}

		.navbar-item:hover, .navbar-item.is-active {
			background-color: #292929 !important ;
		}

		@media screen and (max-width: 1023px)   {
			.navbar-menu{
				background-color: #252629d4 !important;
			}
		}
	</style>
</head>

    <style>
        img {
            max-height: 400px;
        }
    </style>
        <nav
  class="navbar is-fixed-top is-dark"
  role="navigation"
  aria-label="main navigation"
>
  <div class="container" style="max-width: 750px;">
    <div class="navbar-brand">
      <a id="logo" class="navbar-item has-text-weight-bold" href="/">
        <span>&lt;iamaatoh /&gt;</span>
      </a>

      <a
        role="button"
        class="navbar-burger"
        aria-label="menu"
        aria-expanded="false"
        data-target="navbar"
      >
        <span aria-hidden="true"></span>
        <span aria-hidden="true"></span>
        <span aria-hidden="true"></span>
      </a>
    </div>
 
    <div id="navbar" class="navbar-menu">
      <div class="navbar-end">
        <a href="/blog" class="navbar-item is-hoverable is-active">Blog</a>
        <a href="/reads" class="navbar-item is-hoverable ">Bookshelf</a>
        <!-- <a href="/projects" class="navbar-item is-hoverable ">Projects</a> -->
        <a href="/talks" class="navbar-item is-hoverable ">Talks</a>
        <a href="/research" class="navbar-item is-hoverable ">Research</a>
      </div>
    </div>
  </div>
</nav>

        <div style="margin: 52px auto; max-width: 750px; padding: 8px 12px;" class="has-text-grey-light">
            <section class="hero pb-2">
                <nav class="breadcrumb" aria-label="breadcrumbs">
                    <ul class="is-align-items-center">
                        <li><a class="is-size-7" href="/">Home</a></li>
                        <li><a class="is-size-7" href="/blog">Blog</a></li>
                        <li class="is-active is-size-7 is-underlined has-text-ligh">&nbsp;Floored by (math.)floor</li>
                    </ul>
                </nav>
                <h1 class="title is-3 has-text-light">
                    Floored by (math.)floor
                </h1>
                <div>
                    In computing, flooring a number is a common operation. Pretty mundane, but the perks of working with big data is that mundane things get exciting. Big Data breaks language limits.
                </div>
                <br/>
                <div class="is-light is-size-7 has-text-grey-light">
                    Posted on Apr 12, '23</small>
                </div>
            </section>
            <hr/>
            <section class="post pt-2">
                <div class="container">
                    <div class="columns is-6">
                        
                        <div class="fixed column is-one-quarter is-hidden-tablet">
                            <aside class="menu" style="position: sticky; top: 0; padding-top: 80px; margin-top: -80px;">

    <p class="menu-label">
    Approaches
    </p>
    
    <ul class="menu-list has-text-grey-light">
        
            <li class="is-size-7">
                <a class="menu-list-item" href="#math-floor"> Using math.floor</a>
                
            </li>
        
            <li class="is-size-7">
                <a class="menu-list-item" href="#bitwise"> Using bitwise operators</a>
                
                    <ul>
                    
                        <li class="is-size-7">
                            <a class="menu-list-item" href="#bitwise" >>>, >>> or ~~</a>
                        </li>
                        
                        <li class="is-size-7">
                            <a class="menu-list-item" href="#bitwise-work" >Why do bit operators work?</a>
                        </li>
                        
                    </ul>
                
            </li>
        
            <li class="is-size-7">
                <a class="menu-list-item" href="#odd-even"> Using a custom algorithm</a>
                
            </li>
        
            <li class="is-size-7">
                <a class="menu-list-item" href="#performance"> Performance comparisons</a>
                
            </li>
        
            <li class="is-size-7">
                <a class="menu-list-item" href="#math-slow"> But why is math.floor slow? (hint: modulo)</a>
                
            </li>
        
    </ul>
    

</aside>
                        </div>
                        

                        <div class="column  is-three-quarters">
                            <div class="content">
                                <p>Flooring a number is boring.</p>

<p>Javascript has a built-in <code class="language-plaintext highlighter-rouge">Math.floor</code>. Use that, and there’s no reason to think.
That was until we found out it was <strong>four times</strong> more expensive than the alternatives. Quite a rabbit hole.</p>

<p>Here’s what we were trying to do:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Find `c` where `c` is the closest interger less than `(a + b) / 2`.
</code></pre></div></div>

<p>Firstly, I’d never considered an alternative. So I was surprised to find so many.
More importantly - they aren’t all the same.</p>

<h2 id="approaches">Approaches</h2>

<h3 id="math-floor">Use the builtin Math.floor</h3>

<p>There are two ways of doing this:</p>

<p><strong>Option 1</strong></p>

<p><code class="language-plaintext highlighter-rouge">const midpoint = Math.floor((a + b)/2)</code></p>

<p><strong>Option 2</strong></p>

<p><code class="language-plaintext highlighter-rouge">const midpoint = a + Math.floor((b-a)/2)</code></p>

<p>The second option is more commonly used as a way to avoid overflow errors. In Javascript, given that all numbers are represented as 64-bit floating point, it hardly matters thought.</p>

<h3 id="bitwise">Use Bitwise Operators</h3>

<p>Bit operators, like the name suggests, operate on the binary representations hence can be significantly faster. And, they make great shorthands.</p>

<p>So here’s three ways we compared:</p>

<ol>
  <li>With Right Shift (<code class="language-plaintext highlighter-rouge">&gt;&gt;</code>), <code class="language-plaintext highlighter-rouge">const midpoint = a + b &gt;&gt; 1</code></li>
  <li>With Unsigned Right Shift (<code class="language-plaintext highlighter-rouge">&gt;&gt;&gt;</code>) <code class="language-plaintext highlighter-rouge">const midpoint = a + b &gt;&gt;&gt; 1</code></li>
  <li>With Not (<code class="language-plaintext highlighter-rouge">~~</code>), <code class="language-plaintext highlighter-rouge">const midpoint = ~~(a + b)</code></li>
</ol>

<h4 id="bitwise-work">Why do bitwise operators work?</h4>

<p>Shifting a bit by 1, means dividing a number by 2. Easy enough to understand. But why does this operation floor the number?
That was hardly intuitive.</p>

<p>We went back to the docs, and here’s a clue:</p>

<blockquote>
  <p>The Signed Right Shift Operator ( » )
Performs a sign-filling bitwise right shift operation on the left operand by the amount specified by the right operand.
The production <code class="language-plaintext highlighter-rouge">ShiftExpression : ShiftExpression &gt;&gt; AdditiveExpression</code> is evaluated as follows:</p>

  <ol>
    <li>Let lref be the result of evaluating ShiftExpression.</li>
    <li>Let lval be GetValue(lref).</li>
    <li>Let rref be the result of evaluating AdditiveExpression.</li>
    <li>Let rval be GetValue(rref).</li>
    <li>Let lnum be ToInt32(lval).</li>
    <li>Let rnum be ToUint32(rval).</li>
    <li>Let shiftCount be the result of masking out all but the least significant 5 bits of rnum, that is, compute rnum &amp; 0x1F.</li>
    <li>Return the result of performing a sign-extending right shift of lnum by shiftCount bits. The most significant bit is propagated. The result is a signed 32-bit integer.</li>
  </ol>
</blockquote>

<p>See it yet?</p>

<p>Focus here:</p>

<blockquote>
  <p>Let lnum be ToInt32(lval).</p>
</blockquote>

<p>From <a href="https://262.ecma-international.org/5.1/#sec-9.5"><strong>ToInt32: (Signed 32 Bit Integer)</strong></a></p>

<blockquote>
  <p>The abstract operation ToInt32 converts its argument to one of 2^32 integer values in the range −2^31 through 2^31−1, inclusive. This abstract operation functions as follows:</p>

  <p>Let number be the result of calling ToNumber on the input argument.
If number is NaN, +0, −0, +∞, or −∞, return +0.</p>

  <p>Let posInt be sign(number) * floor(abs(number)).</p>

  <p>Let int32bit be posInt modulo 2^32; that is, a finite integer value k
of Number type with positive sign and less than 2^32 in magnitude such that the mathematical difference of posInt and k is mathematically an integer multiple of 232.</p>

  <p>If int32bit is greater than or equal to 2^31, return int32bit − 2^32, otherwise return int32bit.</p>
</blockquote>

<p>More closely,</p>

<blockquote>
  <p>posInt modulo 2^32</p>
</blockquote>

<blockquote>
  <p>Let int be the mathematical value that is the same sign as number and whose magnitude is floor(abs(ℝ(number))).
the 32-bit conversion floors the number internally before performing the operation</p>
</blockquote>

<p>To https://262.ecma-international.org/5.1/#sec-9.6</p>

<p>Hence, all bitwise operators first convert the number into a 32-bit representation, unless it is explicitly a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt"><code class="language-plaintext highlighter-rouge">BigInt</code></a>.</p>

<p>This introduces the following caveats with working with bitwise operators:</p>

<ol>
  <li>With the signed right shift, it only works till 2 ** 31 - 1</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> e.g 2147483648 &gt;&gt; 1 =&gt; -1073741824 \n
 However, `BigInt` with signed right shift always works
 2147483650n &gt;&gt; 1n =&gt; 1073741825n
 BigInt(Number.MAX_VALUE) &gt;&gt; 1n
 =&gt; 89884656743115785407263711865852178399035283762922…072361584369088590459649940625202013092062429184n
</code></pre></div></div>

<ol>
  <li>Unsigned right shift works till 2 ** 32 - 1, (Note: Unsigned right shift doesnt work with bigints)
    <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="mi">4294967295</span> <span class="o">&gt;&gt;&gt;</span> <span class="mi">1</span> <span class="o">=&gt;</span> <span class="mi">2147483647</span>
 <span class="mi">4294967296</span> <span class="o">&gt;&gt;&gt;</span> <span class="mi">1</span> <span class="o">=&gt;</span> <span class="mi">0</span>
</code></pre></div>    </div>
  </li>
  <li>~~ only works for positive numbers.</li>
</ol>

<h3 id="odd-even">Custom Algorithm</h3>

<p>Given the limitation around handling <code class="language-plaintext highlighter-rouge">BigInt</code>s, we also tested our own formula.
Since the context here was only to find a rounded-off midpoint, this worked.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">midpoint</span> <span class="o">=</span> <span class="p">(</span><span class="nx">m</span> <span class="o">+</span> <span class="nx">n</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">===</span> <span class="mi">0</span> <span class="p">?</span> <span class="p">(</span><span class="nx">m</span> <span class="o">+</span> <span class="nx">n</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="p">:</span> <span class="p">(</span><span class="nx">m</span> <span class="o">+</span> <span class="nx">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
</code></pre></div></div>

<p>This did reasonably well, though it wasn’t as fast as Bitwise.</p>

<h4 id="math-slow">But why is Math.floor slow?</h4>

<blockquote>
  <p>The mathematical function floor(x) yields the largest integer (closest to positive infinity) that is not larger than x.
NOTE: floor(x) = x−(x modulo 1).</p>
</blockquote>

<p>And here’s the culprit: Modulo.</p>

<p>And why is modulo slow? Long story short, if you remember grade school math, division was just a way longer process than an addition or subtraction. For a more detailed explanation, check out the great Stackoverflow answers in the references!</p>

<h3 id="performance">Performance Comparisons</h3>

<p>Finally, we took all our approaches and calculated time take for each:</p>

<table>
  <thead>
    <tr>
      <th>Iterations</th>
      <th><code class="language-plaintext highlighter-rouge">Math.floor (add)</code></th>
      <th><code class="language-plaintext highlighter-rouge">Math.floor (subtract)</code></th>
      <th><code class="language-plaintext highlighter-rouge">&gt;&gt;</code></th>
      <th><code class="language-plaintext highlighter-rouge">&gt;&gt;&gt;</code></th>
      <th><code class="language-plaintext highlighter-rouge">~~</code></th>
      <th>Custom</th>
      <th>Modulo</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>100000</td>
      <td>6ms</td>
      <td>4ms</td>
      <td>1ms</td>
      <td>3ms</td>
      <td>2ms</td>
      <td>6ms</td>
      <td>8ms</td>
    </tr>
    <tr>
      <td>1000000</td>
      <td>23ms</td>
      <td>54ms</td>
      <td>14ms</td>
      <td>19ms</td>
      <td>19ms</td>
      <td>33ms</td>
      <td>56ms</td>
    </tr>
    <tr>
      <td>1000000</td>
      <td>54ms</td>
      <td>24ms</td>
      <td>14ms</td>
      <td>18ms</td>
      <td>19ms</td>
      <td>24ms</td>
      <td>57ms</td>
    </tr>
    <tr>
      <td>1000000</td>
      <td>58ms</td>
      <td>-</td>
      <td>14ms</td>
      <td>19ms</td>
      <td>19ms</td>
      <td>26ms</td>
      <td>65ms</td>
    </tr>
    <tr>
      <td>1000000</td>
      <td>-</td>
      <td>56ms</td>
      <td>22ms</td>
      <td>15ms</td>
      <td>19ms</td>
      <td>26ms</td>
      <td>62ms</td>
    </tr>
    <tr>
      <td>10000000</td>
      <td>227ms</td>
      <td>575ms</td>
      <td>151ms</td>
      <td>223ms</td>
      <td>222ms</td>
      <td>269ms</td>
      <td>569ms</td>
    </tr>
  </tbody>
</table>

<h3 id="takeaways">Takeaways</h3>

<ol>
  <li>Bitwise operators outperform <code class="language-plaintext highlighter-rouge">Math.floor</code> by roughly 2-4 times for all sample sizes.</li>
  <li>Modulo sucks.</li>
  <li>Our custom algorithm didn’t do too badly, performing better than Math.floor.</li>
  <li>There is some memoization (or magic!) happening with Math.floor. The first usage of Math.floor is slower and successive usage of Math.floor get faster.</li>
</ol>

<h3 id="references">References</h3>

<ul>
  <li>https://262.ecma-international.org/12.0/#sec-touint32</li>
  <li>https://2ality.com/2012/04/number-encoding.html</li>
  <li>https://262.ecma-international.org/5.1/#sec-9.6</li>
  <li>https://262.ecma-international.org/5.1/#sec-11.7.2</li>
  <li>https://stackoverflow.com/questions/36228869/best-way-finding-the-middle-point</li>
  <li>https://stackoverflow.com/questions/5971645/what-is-the-double-tilde-operator-in-javascript</li>
  <li>https://stackoverflow.com/questions/27977834/why-is-modulus-operator-slow</li>
</ul>

                            </div>
                        </div>

                        
                        <div class="column is-one-quarter is-hidden-mobile ">
                            <aside class="menu" style="position: sticky; top: 0; padding-top: 80px; margin-top: -80px;">

    <p class="menu-label">
    Approaches
    </p>
    
    <ul class="menu-list has-text-grey-light">
        
            <li class="is-size-7">
                <a class="menu-list-item" href="#math-floor"> Using math.floor</a>
                
            </li>
        
            <li class="is-size-7">
                <a class="menu-list-item" href="#bitwise"> Using bitwise operators</a>
                
                    <ul>
                    
                        <li class="is-size-7">
                            <a class="menu-list-item" href="#bitwise" >>>, >>> or ~~</a>
                        </li>
                        
                        <li class="is-size-7">
                            <a class="menu-list-item" href="#bitwise-work" >Why do bit operators work?</a>
                        </li>
                        
                    </ul>
                
            </li>
        
            <li class="is-size-7">
                <a class="menu-list-item" href="#odd-even"> Using a custom algorithm</a>
                
            </li>
        
            <li class="is-size-7">
                <a class="menu-list-item" href="#performance"> Performance comparisons</a>
                
            </li>
        
            <li class="is-size-7">
                <a class="menu-list-item" href="#math-slow"> But why is math.floor slow? (hint: modulo)</a>
                
            </li>
        
    </ul>
    

</aside>
                        </div>
                        
                    </div>
                </div>
            </section>
        </div>

        <footer style="max-width: 750px; margin: 0 auto" class="pb-2"><small>Copyright © 2023 iamaatoh.com</small></footer>
    </body>
</html>